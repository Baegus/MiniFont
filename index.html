<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>MiniFont: Remove unused glyphs</title>
	<meta name="description" content="Minify font files by removing unused glyphs.">
	<meta name="author" content="Baegus">
	<meta name="keywords" content="font, minify, typeface, subset, ttf, otf, woff, web font, glyphs, optimization, optimize, shrink">
	<style>
		:root {
			--bg: #1e273e;
			--surface: #2b3759;
			--container-shadow: rgba(0, 0, 0, 0.3);
			--neutral-gray: rgb(151, 151, 151);
			--primary: #ffaa13;
			--primary-hover: #d99110;
			--text: #ffffff;
			--text-muted: #979797;
			--border: #414a65;
			--success: #22c55e;
			--error-fg-bright: #ff8080;
			--error-fg: #ffcdcd;
			--error-bg: #8d2c2c;
		}

		* { box-sizing: border-box; }

		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			background-color: var(--bg);
			color: var(--text);
			margin: 0;
			padding: 20px;
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding-top: 80px;
		}

		.container {
			width: 100%;
			max-width: 800px;
			display: flex;
			flex-direction: column;
			gap: 24px;
		}

		header {
			text-align: center;
			margin-bottom: 10px;
		}

		/* Header styles */
		header {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			height: 60px;
			background-color: var(--surface);
			box-shadow: 0 2px 8px var(--container-shadow);
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 0 20px;
			z-index: 1000;
		}

		.header-left {
			display: flex;
			align-items: center;
			text-align: left;
			gap: 12px;
		}

		.logo {
			width: 40px;
			height: 40px;
			background: url("logo.svg") center/contain no-repeat;
			background-color: var(--secondary);
			padding: 5px;
			flex-shrink: 0;
		}

		.app-title {
			font-size: 18px;
			line-height: 1.2;
			font-weight: 600;
			color: var(--text-light);
			margin: 0;
		}

		.header-right {
			color: var(--neutral-gray);
			font-size: 14px;
		}

		.header-right span:first-child::after {
			content: " | ";
		}

		.header-right a {
			color: var(--primary);
			text-decoration: none;
		}

		.header-right a:hover {
			text-decoration: underline;
		}

		/* Cards */
		.card {
			background: var(--surface);
			border: 1px solid var(--border);
			padding: 24px;
			box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
		}

		/* Upload Zone */
		.drop-zone {
			border: 2px dashed var(--border);
			padding: 40px;
			text-align: center;
			transition: all 0.2s;
			cursor: pointer;
			position: relative;
		}

		.drop-zone:hover, .drop-zone.dragover {
			border-color: var(--primary);
			background: rgba(59, 130, 246, 0.05);
		}

		.drop-zone input {
			position: absolute;
			top: 0; left: 0; width: 100%; height: 100%;
			opacity: 0;
			cursor: pointer;
		}

		.file-info {
			font-weight: 600;
			color: var(--primary);
		}

		/* Inputs */
		label {
			display: block;
			margin-bottom: 8px;
			font-weight: 600;
			font-size: 0.9rem;
			color: var(--text);
		}

		textarea,
		.textarea-like {
			width: 100%;
			background: var(--bg);
			border: 1px solid var(--border);
			color: var(--text);
			font-family: monospace;
			font-size: 1rem;
			min-height: 120px;
			padding: 12px;
			resize: vertical;
			overflow: auto;
			white-space: pre-wrap;
			word-break: break-all;
		}

		textarea:focus,
		.textarea-like:focus {
			outline: none;
			border-color: var(--primary);
		}

		.char-removed {
			color: var(--error-fg-bright);
			opacity: 0.7;
		}

		/* Controls */
		.controls {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			margin-top: 4px;
			align-items: end;
		}

		select {
			width: 100%;
			padding: 10px;
			background: var(--bg);
			color: var(--text);
			border: 1px solid var(--border);
		}

		.presetLabelWrap {
			display: flex;
			justify-content: space-between;
			align-items: center;
			gap: 10px;
			flex-wrap: wrap;
		}

		#presetSelect {
			width: auto;
			max-width: 100%;
			padding: 4px;
			font-size: 0.9rem;
			border: 1px solid var(--border);
			background: var(--bg);
			color: var(--text);
		}

		/* Stats & Action */
		.stats-bar {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background: rgba(0,0,0,0.2);
			padding: 15px;
			margin-top: 20px;
		}

		.stat-item {
			display: flex;
			flex-direction: column;
			flex: 1;
			align-items: center;
		}

		.stat-label { font-size: 0.8rem; color: var(--text-muted); }
		.stat-value { font-size: 1.2rem; font-weight: bold; font-variant-numeric: tabular-nums; }
		.arrow { color: var(--text-muted); font-size: 1.2rem; }
		
		.saving { color: var(--success); font-size: 0.8rem; margin-top: 2px; }

		button.btn-primary {
			background: var(--primary);
			color: var(--surface);
			border: none;
			padding: 0 24px;
			height: 48px;
			display: flex;
			justify-content: center;
			align-items: center;
			font-weight: 600;
			cursor: pointer;
			font-size: 1rem;
			transition: background 0.2s;
			width: 100%;
			margin-top: 10px;
		}

		button.btn-primary:hover { background: var(--primary-hover); }
		button.btn-primary:disabled { background: var(--border); cursor: not-allowed; opacity: 0.7; }

		.error-msg {
			color: var(--error-fg);
			background: var(--error-bg);
			padding: 10px;
			margin-top: 10px;
			display: none;
			font-size: 0.9rem;
		}

		/* Loading Spinner */
		.spinner {
			display: none;
			width: 20px;
			height: 20px;
			border: 3px solid rgba(255,255,255,0.3);
			border-radius: 50%;
			border-top-color: #fff;
			animation: spin 1s ease-in-out infinite;
			margin: 0 auto;
		}

		@keyframes spin { to { transform: rotate(360deg); } }

		@media(max-width: 720px) {
			body {
				padding: 75px 0 0 0;
			}

			h2 {
				font-size: 18px;
			}

			header {
				padding: 0 7px;
			}

			.header-left {
				gap: 8px;
				width: 60%;
			}

			.logo {
				width: 30px;
				height: 30px;
			}

			.app-title {
				font-size: 16px;
			}

			.subtitle {
				font-size: 12px;
				display: block;
			}

			.header-right {
				font-size: 12px;
			}

			.header-right span {
				display: block;
			}

			.header-right span::after {
				display: none;
			}

			.container {
				padding: 15px;
				max-width: 100%;
			}
		}

		@media (max-width: 600px) {
			.controls { grid-template-columns: 1fr; }
		}
	</style>
</head>
<body>

<div class="container">
	<header>
		<div class="header-left">
			<div class="logo"></div>
			<h1 class="app-title">MiniFont: <span class="subtitle">Remove unused glyphs</span></h1>
		</div>
		<div class="header-right">
			<span>Made by <a href="https://baegus.cz" target="_blank">Baegus</a></span>
			<span>Star on <a href="https://github.com/Baegus/MiniFont" target="_blank">GitHub</a></span>
		</div>
	</header>

	<!-- Upload Section -->
	<div class="card">
		<div class="drop-zone" id="dropZone">
			<input type="file" id="fileInput" accept=".ttf, .otf, .woff, .woff2, .eot">
			<div id="dropText">
				<span>Drag & Drop your font&nbsp;here</span>
				<br>
				<span style="font-size: 0.8em; color: var(--text-muted);">(TTF, OTF, WOFF, WOFF2, EOT)</span>
			</div>
			<div class="file-info" id="fileInfo"></div>
		</div>
		<div class="error-msg" id="errorMsg"></div>
	</div>

	<!-- Configuration Section -->
	<div class="card" id="configCard" style="opacity: 0.5; pointer-events: none;">
		<div class="presetLabelWrap">
			<label for="keptCharsInput" style="margin-bottom: 0;">Characters to keep</label>
			<select id="presetSelect">
				<option value="">No preset</option>
				<option value="allCharacters">Keep all characters</option>
			</select>
		</div>
		<textarea id="keptCharsInput" spellcheck="false"></textarea>

		<label for="allCharsOutput">Available characters in the loaded font (Red = Removed)</label>
		<div id="allCharsOutput" class="textarea-like" tabindex="0">Load a font to see available characters...</div>

		<div class="controls">
			<div>
				<label for="formatSelect">Output format</label>
				<select id="formatSelect">
					<option value="woff2">WOFF2 (Web Open Font Format 2)</option>
					<option value="woff">WOFF (Web Open Font Format)</option>
					<option value="ttf">TTF (TrueType)</option>
					<option value="otf">OTF (OpenType)</option>
					<option value="svg">SVG (Scalable Vector Graphics)</option>
				</select>
			</div>
			<div>
				<!-- Placeholder for potential future options like preserving kerning -->
			</div>
		</div>

		<div class="stats-bar">
			<div class="stat-item">
				<span class="stat-label">Original Size</span>
				<span class="stat-value" id="origSize">0 KB</span>
				<div style="margin-top: 4px; font-size: 0.8rem; color: var(--text-muted);">
					<span id="origGlyphs">-</span> glyphs
				</div>
			</div>
			<div class="arrow">➔</div>
			<div class="stat-item">
				<span class="stat-label">Minified Size</span>
				<span class="stat-value" id="newSize">0 KB</span>
				<div style="margin-top: 4px; font-size: 0.8rem; color: var(--text-muted);">
					<span id="newGlyphs">-</span> glyphs
				</div>
				<span class="saving" id="savings"></span>
			</div>
		</div>

		<button id="downloadBtn" class="btn-primary" disabled>
			<span class="btn-text">Download Font</span>
			<div class="spinner" id="loadingSpinner"></div>
		</button>
	</div>
</div>


<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<script type="module">
	import pako from "https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.esm.mjs";
	// Make pako globally accessible (for Typr)
	window.pako = pako;
</script>
<script src="Typr.js"></script>
<script src="Typr.U.js"></script>
<script src="Typr.Writr.js"></script>
<script type="module">
	function getID(id) {
		return document.getElementById(id);
	}

	// DOM Elements
	const dropZone = getID("dropZone");
	const fileInput = getID("fileInput");
	const fileInfo = getID("fileInfo");
	const dropText = getID("dropText");
	const configCard = getID("configCard");
	const keptCharsInput = getID("keptCharsInput");
	const allCharsOutput = getID("allCharsOutput");
	const formatSelect = getID("formatSelect");
	const downloadBtn = getID("downloadBtn");
	const origSizeEl = getID("origSize");
	const newSizeEl = getID("newSize");
	const savingsEl = getID("savings");
	const origGlyphsEl = getID("origGlyphs");
	const newGlyphsEl = getID("newGlyphs");
	const errorMsg = getID("errorMsg");
	const loadingSpinner = getID("loadingSpinner");
	const btnText = document.querySelector(".btn-text");
	const presetSelect = getID("presetSelect");

	// Presets
	const AtoZ = `ABCDEFGHIJKLMNOPQRSTUVWXYZ`;
	const AtoZ_lower = AtoZ.toLowerCase();
	const numbers = `0123456789`;
	const alphanum = `${AtoZ}${AtoZ_lower}${numbers}`;
	const commonSpecialChars = `!"'#$%&() \u00a0{}[]„“ˇ\´\` * +,-× _ ^| ~./\\: ;<=>? @©®`;
	const presets = {
		"English (Latin + common characters)": `${commonSpecialChars}${alphanum}`,
		"Spanish (Latin + common characters)": `${commonSpecialChars}${alphanum}ÁÉÍÓÚÜÑáéíóúüñ¿¡«»`,
		"German (Latin + common characters)": `${commonSpecialChars}${alphanum}ÄÖÜäöüß`,
		"French (Latin + common characters)": `${commonSpecialChars}${alphanum}ÀÂÆÇÉÈÊËÏÎÔŒÙÛÜàâæçéèêëïîôœùûüŸÿ«»€`,
		"Polish (Latin + common characters)": `${commonSpecialChars}${alphanum}ĄĆĘŁŃÓŚŹŻąćęłńóśźż`,
		"Turkish (Latin + common characters)": `${commonSpecialChars}${alphanum}ÇĞİIÖŞÜçğıöşü`,
		"Portuguese (Latin + common characters)": `${commonSpecialChars}${alphanum}ÁÂÃÇÉÊÍÓÔÕÚáâãçéêíóôõú«»`,
		"Italian (Latin + common characters)": `${commonSpecialChars}${alphanum}ÀÈÉÌÍÒÓÙÚàèéìíòóùú`,
		"Dutch (Latin + common characters)": `${commonSpecialChars}${alphanum}ÉéËëÏï`,
		"Scandinavian (Latin + common characters)": `${commonSpecialChars}${alphanum}ÆØÅæøåÄÖÜäöü`,
		"Czech (Latin + common characters)": `${commonSpecialChars}${alphanum}ÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž`,
		"Slovak (Latin + common characters)": `${commonSpecialChars}${alphanum}ÁÄČĎÉÍĽĹŇÓÔŔŠŤÚÝŽáäčďéíľĺňóôŕšťúýž`,
		"Romanian (Latin + common characters)": `${commonSpecialChars}${alphanum}ĂÂÎȘȚăâîșț`,
		"Ukrainian (Cyrillic)": `АБВГҐДЕЄЖЗИІЇЙКЛМНОПРСТУФХЦЧШЩЬЮЯабвгґдеєжзиіїйклмнопрстуфхцчшщьюя0123456789 .,-!"'?:;`,
		"Russian (Cyrillic)": `АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя0123456789 .,-!"'?:;`,
		"Greek": `ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρστυφχψωΆΈΉΊΌΎΏΐΪΫάέήίόύώ 0123456789 .,-!"'?:;`,
		"Japanese (Hiragana + Katakana)": `ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴー。、・「」『』【】〒〓〔〕〈〉《》〝〟〜`,
		"Numbers only": numbers,
		"Math": `${numbers}+-=*/()[]{}<>≠≈≤≥±÷×√∑∏∫∂∞∇∈∉∪∩⊂⊃⊆⊇∀∃∴∵`,
		"Basic Latin + Numbers": alphanum,
	};

	// Populate presets
	for (const name of Object.keys(presets)) {
		const opt = document.createElement("option");
		opt.value = name;
		opt.textContent = name;
		presetSelect.appendChild(opt);
	}

	// Load saved characters
	const savedChars = localStorage.getItem("MiniFont_keptChars");
	if (savedChars) {
		keptCharsInput.value = savedChars;
	} else {
		keptCharsInput.value = presets["English (Latin + common characters)"];
	}

	// State
	let currentOriginalFont = null;
	let currentOriginalBuffer = null;
	let currentFileName = "";
	let currentAllChars = [];
	let generatedBuffer = null;
	let debounceTimer;
	
	// Preset State
	let customKeptChars = keptCharsInput.value;
	let previousPreset = "";

	// --- Event Listeners ---

	// Drag & Drop visual feedback
	let dragCounter = 0;

	// Window listeners (Global drop when no font loaded)
	window.addEventListener("dragenter", (e) => {
		e.preventDefault();
		if (currentOriginalFont) return;
		
		dragCounter++;
		dropZone.classList.add("dragover");
	});

	window.addEventListener("dragleave", () => {
		if (currentOriginalFont) return;
		
		dragCounter--;
		if (dragCounter === 0) {
			dropZone.classList.remove("dragover");
		}
	});

	window.addEventListener("dragover", (e) => {
		if (currentOriginalFont) return;
		e.preventDefault();
	});

	window.addEventListener("drop", (e) => {
		if (currentOriginalFont) return;
		e.preventDefault();

		dragCounter = 0;
		dropZone.classList.remove("dragover");
		if(e.dataTransfer.files.length) {
			handleFile(e.dataTransfer.files[0]);
		}
	});

	// DropZone listeners (Specific behavior)
	dropZone.addEventListener("dragover", (e) => {
		e.preventDefault();
		dropZone.classList.add("dragover");
	});

	dropZone.addEventListener("dragleave", () => {
		// Only remove class if we are in "font loaded" mode.
		// In "no font" mode, the window listener handles removal when leaving the window.
		if (currentOriginalFont) {
			dropZone.classList.remove("dragover");
		}
	});

	dropZone.addEventListener("drop", (e) => {
		e.preventDefault();
		e.stopPropagation(); // Prevent window drop listener from firing
		dropZone.classList.remove("dragover");
		if(e.dataTransfer.files.length) {
			handleFile(e.dataTransfer.files[0]);
		}
	});

	fileInput.addEventListener("change", (e) => {
		if(e.target.files.length) {
			handleFile(e.target.files[0]);
		}
	});

	// Recalculate on Input Change (Debounced)
	keptCharsInput.addEventListener("input", () => {
		if (presetSelect.value === "") {
			customKeptChars = keptCharsInput.value;
		} else {
			// User edited a preset -> switch to "No preset"
			previousPreset = "";
			presetSelect.value = "";
			customKeptChars = keptCharsInput.value;
		}

		localStorage.setItem("MiniFont_keptChars", keptCharsInput.value);
		updateCharDisplay();
		clearTimeout(debounceTimer);
		debounceTimer = setTimeout(processFont, 100);
	});

	presetSelect.addEventListener("change", () => {
		const currentPreset = presetSelect.value;
		
		if (previousPreset === "") {
			// We are switching away from "No preset" (custom), so save it
			customKeptChars = keptCharsInput.value;
		}

		if (currentPreset === "") {
			// Restore custom
			keptCharsInput.value = customKeptChars;
		} else if (currentPreset === "allCharacters") {
			keptCharsInput.value = currentAllChars.join("");
		} else {
			// Apply preset
			keptCharsInput.value = presets[currentPreset];
		}

		previousPreset = currentPreset;
		
		// Trigger updates
		localStorage.setItem("MiniFont_keptChars", keptCharsInput.value);
		updateCharDisplay();
		processFont();
	});

	formatSelect.addEventListener("change", () => {
		processFont();
	});

	downloadBtn.addEventListener("click", downloadFont);

	// --- Core Logic ---

	async function handleFile(file) {
		resetError();
		
		// Update UI
		dropText.style.display = "none";
		fileInfo.textContent = `Loading: ${file.name}`;
		currentFileName = file.name;
		
		// Read file
		try {
			let arrayBuffer = await file.arrayBuffer();
			const originalBuffer = arrayBuffer;
			
			// Check for WOFF2 signature: wOF2 (0x774F4632)
			const view = new DataView(arrayBuffer);
			if (arrayBuffer.byteLength > 4 && view.getUint32(0) === 0x774F4632) {
				try {
					fileInfo.textContent = `Decompressing WOFF2: ${file.name}...`;
					arrayBuffer = await woff2ToTtf(arrayBuffer);
				} catch (e) {
					throw new Error("Failed to decompress WOFF2: " + e.message);
				}
			} else if (file.name.toLowerCase().endsWith(".eot")) {
				// Try to extract TTF from EOT
				try {
					const eotSize = view.getUint32(0, true);
					const fontDataSize = view.getUint32(4, true);
					
					if (eotSize === arrayBuffer.byteLength) {
						const flags = view.getUint32(12, true);
						if (flags & 0x00000004) {
							throw new Error("Compressed EOT (MTX) input is not supported.");
						}
						
						const headerSize = eotSize - fontDataSize;
						if (headerSize > 0 && headerSize < eotSize) {
							arrayBuffer = arrayBuffer.slice(headerSize);
							fileInfo.textContent = `Extracted TTF from EOT: ${file.name}...`;
						}
					}
				} catch (e) {
					console.warn("Failed to parse EOT header", e);
				}
			} else if (file.name.toLowerCase().endsWith(".svg")) {
				throw new Error("SVG font input is not currently supported (Output only).");
			}

			currentOriginalBuffer = originalBuffer;
			
			// Parse font with Typr.js
			const fonts = Typr.parse(arrayBuffer);
			if (!fonts || fonts.length === 0) {
				throw new Error("Typr.js could not parse the font.");
			}
			currentOriginalFont = fonts[0];

			// Populate available characters
			currentAllChars = getTyprAvailableChars(currentOriginalFont);

			if (presetSelect.value === "allCharacters") {
				keptCharsInput.value = currentAllChars.join("");
			}

			updateCharDisplay();

			// Load font for preview
			try {
				const fontName = "PreviewFont_" + Date.now();
				const fontFace = new FontFace(fontName, arrayBuffer);
				await fontFace.load();
				document.fonts.add(fontFace);
				keptCharsInput.style.fontFamily
					= allCharsOutput.style.fontFamily
					= `"${fontName}", monospace`;
			} catch (e) {
				console.warn("Failed to load font for preview:", e);
				keptCharsInput.style.fontFamily
					= allCharsOutput.style.fontFamily
					= `monospace`;
			}
			
			// Show Stats
			origSizeEl.textContent = formatBytes(currentOriginalBuffer.byteLength);
			origGlyphsEl.textContent = currentOriginalFont.maxp.numGlyphs;
			
			// Enable UI
			configCard.style.opacity = "1";
			configCard.style.pointerEvents = "auto";
			
			// Trigger initial processing
			processFont();

		} catch (err) {
			showError("Could not parse this font file. It might be corrupted or an unsupported format.");
			console.error(err);
			fileInfo.textContent = "";
			dropText.style.display = "block";
		}
	}

	async function processFont() {
		if (!currentOriginalFont) return;
		
		setLoading(true);

		try {
			let chars;
			if (presetSelect.value === "allCharacters") {
				// Use the original character list directly to avoid textarea normalization issues (e.g. \r vs \n)
				chars = currentAllChars.join("");
			} else {
				chars = keptCharsInput.value;
			}
			const format = formatSelect.value;
			
			// Create new Font Buffer using Typr.Writer
			let buffer = Typr.Writer.write(currentOriginalFont, chars);

			// Get new glyph count (parse the TTF buffer before conversion)
			try {
				const tempFonts = Typr.parse(buffer);
				if(tempFonts && tempFonts.length > 0) {
					newGlyphsEl.textContent = tempFonts[0].maxp.numGlyphs;
				}
			} catch(e) {
				console.warn("Could not parse generated font for stats", e);
				newGlyphsEl.textContent = "?";
			}

			// Convert to WOFF/WOFF2 if requested
			if (format === "woff") {
				buffer = ttfToWoff(buffer);
			} else if (format === "woff2") {
				buffer = await ttfToWoff2(buffer);
			} else if (format === "svg") {
				const svgString = fontToSvgTypr(currentOriginalFont, chars);
				buffer = new TextEncoder().encode(svgString).buffer;
			}

			generatedBuffer = buffer;

			// Update UI
			newSizeEl.textContent = formatBytes(buffer.byteLength);
			
			const ratio = buffer.byteLength / currentOriginalBuffer.byteLength;
			const savings = Math.abs((1 - ratio) * 100).toFixed(1);
			
			if (ratio > 1) {
				savingsEl.textContent = `(+${savings}%)`;
				savingsEl.style.color = "var(--error-fg)";
			} else {
				savingsEl.textContent = `(-${savings}%)`;
				savingsEl.style.color = "var(--success)";
			}

			downloadBtn.disabled = false;
			fileInfo.textContent = `Loaded: ${currentFileName}`;
		} catch (err) {
			showError("Error generating font subset: " + err.message);
			console.error(err);
		} finally {
			setLoading(false);
		}
	}

	// Helper to get all characters from Typr font
	function getTyprAvailableChars(font) {
		const chars = [];
		const cmap = font.cmap;
		let tab = null;
		
		// Select best table (logic matches Typr.U.codeToGlyph)
		// Typr.U priorities:
		const priorities = [
			"p3e10", "p0e4", "p3e1", "p1e0", "p0e3", "p0e1", "p3e0", "p3e5"
		];
		
		for (let p of priorities) {
			const index = cmap.ids[p];
			if (index == null) continue;
			tab = cmap.tables[index];
			break;
		}

		if (!tab && cmap.tables.length > 0) tab = cmap.tables[0]; // Fallback

		if (!tab) return [];

		// Force Typr.U to use this table to ensure consistency
		font["_ctab"] = tab;

		// Typr.js parses cmap tables eagerly, so tab is already the parsed object
		if (tab.format == 4) {
			const data = tab; // tab itself contains the properties for format 4
			for (let i = 0; i < data.endCount.length; i++) {
				const start = data.startCount[i];
				const end = data.endCount[i];
				for (let c = start; c <= end; c++) {
					if (c > 0x10FFFF) continue; // Invalid Unicode
					// Verify if it maps to a valid glyph
					const gid = Typr.U.codeToGlyph(font, c);
					if (gid == 0) continue;
					// Exclude control characters (0-31, 127-159) and non-characters to prevent rendering issues
					if (c < 32) continue;
					if (c >= 127 && c <= 159) continue;
					if (c === 0xFFFF) continue;
					
					chars.push(String.fromCodePoint(c));
				}
			}
		} else if (tab.format == 12) {
			const data = tab; // tab itself contains the properties for format 12
			const groups = data.groups;
			for (let i = 0; i < groups.length; i += 3) {
				const start = groups[i];
				const end = groups[i + 1];
				for (let c = start; c <= end; c++) {
					if (c > 0x10FFFF) continue;
					// Verify if it maps to a valid glyph (and passes Typr.U validation)
					const gid = Typr.U.codeToGlyph(font, c);
					if (gid == 0) continue;
					if (c < 32) continue;
					if (c >= 127 && c <= 159) continue;
					if (c === 0xFFFF) continue;
					chars.push(String.fromCodePoint(c));
				}
			}
		} else if (tab.format == 0) {
			for (let c = 0; c < 256; c++) {
				if (Typr.U.codeToGlyph(font, c) == 0) continue;
				if (c < 32) continue;
				if (c >= 127 && c <= 159) continue;
				chars.push(String.fromCodePoint(c));
			}
		} else if (tab.format == 6) {
			const firstCode = tab.firstCode;
			const entryCount = tab.glyphIdArray.length;
			for (let i = 0; i < entryCount; i++) {
				const c = firstCode + i;
				if (c > 0x10FFFF) continue;
				const gid = tab.glyphIdArray[i];
				if (gid == 0) continue;
				if (c < 32) continue;
				if (c >= 127 && c <= 159) continue;
				if (c === 0xFFFF) continue;
				chars.push(String.fromCodePoint(c));
			}
		}

		
		return chars;
	}

	function downloadFont() {
		if (!generatedBuffer) return;

		const format = formatSelect.value;
		const nameParts = currentFileName.split(".");
		const suffix = presetSelect.value === "" ? "min" : presetSelect.value.split(/\s+/)[0].toLowerCase();
		const name = `${nameParts.slice(0, -1).join(".")}_${suffix}.${format}`;

		const blob = new Blob([generatedBuffer], { type: `font/${format}` });
		
		saveAs(blob, name);
	}

	// --- Utilities ---

	function formatBytes(bytes, decimals = 2) {
		if (!+bytes) return "0 Bytes";
		const k = 1024;
		const dm = decimals < 0 ? 0 : decimals;
		const sizes = ["Bytes", "KB", "MB"];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
	}

	function showError(msg) {
		errorMsg.textContent = msg;
		errorMsg.style.display = "block";
		configCard.style.opacity = "0.5";
		configCard.style.pointerEvents = "none";
	}

	function resetError() {
		errorMsg.style.display = "none";
	}

	function setLoading(isLoading) {
		if (isLoading) {
			loadingSpinner.style.display = "block";
			btnText.style.display = "none";
		} else {
			loadingSpinner.style.display = "none";
			btnText.style.display = "inline";
		}
	}

	const wawoff2Workers = {};

	async function runWawoff2(mode, buffer) {
		return new Promise((resolve, reject) => {
			if (!wawoff2Workers[mode]) {
				const scriptUrl = mode === "compress" 
					? "https://cdn.jsdelivr.net/npm/wawoff2@2.0.1/build/compress_binding.js"
					: "https://cdn.jsdelivr.net/npm/wawoff2@2.0.1/build/decompress_binding.js";

				const workerCode = `
					importScripts("${scriptUrl}");
					
					onmessage = function(e) {
						const { id, data } = e.data;
						
						const check = () => {
							if (self.Module && (self.Module.compress || self.Module.decompress)) {
								try {
									let output;
									if ("${mode}" === "compress") {
										output = self.Module.compress(data);
									} else {
										output = self.Module.decompress(data);
									}
									
									// Ensure we have a clean buffer copy to transfer
									// output is usually a Uint8Array view on WASM heap
									const result = new Uint8Array(output); 
									postMessage({id, success: true, data: result}, [result.buffer]);
								} catch(err) {
									postMessage({id, success: false, error: err.message});
								}
							} else {
								setTimeout(check, 50);
							}
						};
						check();
					}
				`;

				const blob = new Blob([workerCode], { type: "application/javascript" });
				const workerUrl = URL.createObjectURL(blob);
				const worker = new Worker(workerUrl);
				URL.revokeObjectURL(workerUrl);
				wawoff2Workers[mode] = worker;
			}

			const worker = wawoff2Workers[mode];
			const id = Math.random().toString(36).slice(2);

			const handleMessage = (e) => {
				if (e.data.id !== id) return;
				worker.removeEventListener("message", handleMessage);
				worker.removeEventListener("error", handleError);
				
				if (e.data.success) {
					resolve(e.data.data.buffer);
				} else {
					reject(new Error("WOFF2 " + mode + " failed: " + e.data.error));
				}
			};

			const handleError = (e) => {
				worker.removeEventListener("message", handleMessage);
				worker.removeEventListener("error", handleError);
				wawoff2Workers[mode] = null;
				try { worker.terminate(); } catch(err) {}
				reject(new Error("Worker error: " + e.message));
			};

			worker.addEventListener("message", handleMessage);
			worker.addEventListener("error", handleError);

			worker.postMessage({ id, data: new Uint8Array(buffer) });
		});
	}

	async function ttfToWoff2(ttfBuffer) {
		return runWawoff2("compress", ttfBuffer);
	}

	async function woff2ToTtf(woff2Buffer) {
		return runWawoff2("decompress", woff2Buffer);
	}

	function fontToSvgTypr(font, chars) {
		const fontFamily = font.name.fontFamily || "MiniFont";
		const weight = font["OS/2"]?.usWeightClass || 400;
		const unitsPerEm = font.head.unitsPerEm;
		const ascender = font.hhea.ascender;
		const descender = font.hhea.descender;
		
		let svg = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" >
<svg xmlns="http://www.w3.org/2000/svg">
<defs>
<font id="${fontFamily.replace(/\s/g, "")}" horiz-adv-x="${unitsPerEm}">
<font-face font-family="${fontFamily}" font-weight="${weight}" font-stretch="normal" units-per-em="${unitsPerEm}" ascent="${ascender}" descent="${descender}" />
<missing-glyph horiz-adv-x="${font.hmtx.aWidth[0]}" />
`;

		// Add glyphs
		// We need to iterate over chars
		for (const char of chars) {
			const code = char.codePointAt(0);
			const gid = Typr.U.codeToGlyph(font, code);
			if (gid === 0) continue;
			
			const unicode = "&#x" + code.toString(16) + ";";
			const path = Typr.U.glyphToPath(font, gid);
			const d = pathToSvgData(path);
			const advanceWidth = font.hmtx.aWidth[gid];
			
			if (d) {
				svg += `<glyph unicode="${unicode}" d="${d}" horiz-adv-x="${advanceWidth}" />\n`;
			} else {
				svg += `<glyph unicode="${unicode}" horiz-adv-x="${advanceWidth}" />\n`;
			}
		}

		svg += `</font>
</defs>
</svg>`;

		return svg.replace(/[\n\r]+/g, "");
	}

	function pathToSvgData(path) {
		let d = "";
		let cmds = path.cmds;
		let crds = path.crds;
		let ci = 0;
		for(let i=0; i<cmds.length; i++) {
			let cmd = cmds[i];
			if(cmd=="M") { d += `M${crds[ci]} ${crds[ci+1]} `; ci+=2; }
			else if(cmd=="L") { d += `L${crds[ci]} ${crds[ci+1]} `; ci+=2; }
			else if(cmd=="Q") { d += `Q${crds[ci]} ${crds[ci+1]} ${crds[ci+2]} ${crds[ci+3]} `; ci+=4; }
			else if(cmd=="C") { d += `C${crds[ci]} ${crds[ci+1]} ${crds[ci+2]} ${crds[ci+3]} ${crds[ci+4]} ${crds[ci+5]} `; ci+=6; }
			else if(cmd=="Z") { d += "Z "; }
		}
		return d.trim();
	}

	/**
	 * Converts a TTF ArrayBuffer to a WOFF ArrayBuffer
	 * WOFF is a wrapper around TTF table data with ZLIB compression.
	 */
	function ttfToWoff(ttfBuffer) {
		const ttfData = new Uint8Array(ttfBuffer);
		
		// WOFF Header constants
		const SIGNATURE = 0x774F4646; // "wOFF"
		const FLAVOR = 0x00010000;    // 1.0
		const HEADER_SIZE = 44;

		const view = new DataView(ttfBuffer);
		const numTables = view.getUint16(4);
		
		// Read Table Directory
		const tables = [];
		let offset = 12; // Start of Table Directory

		for (let i = 0; i < numTables; i++) {
			const tag = getTag(view, offset);
			const checkSum = view.getUint32(offset + 4);
			const offsetVal = view.getUint32(offset + 8);
			const length = view.getUint32(offset + 12);
			tables.push({ tag, checkSum, offset: offsetVal, length, origOffset: offset });
			offset += 16;
		}

		// Calculate WOFF size
		let woffSize = HEADER_SIZE + (numTables * 20); // Header + Directory
		let woffOffset = woffSize;

		// Compress tables and calculate new offsets
		const tableData = [];
		for(let table of tables) {
			const data = ttfData.slice(table.offset, table.offset + table.length);
			
			// Compress
			const compressed = pako.deflate(data);
			
			// If compressed is larger than original, store original
			let finalData, compLength;
			if (compressed.length >= table.length) {
				finalData = data;
				compLength = table.length;
			} else {
				finalData = compressed;
				compLength = compressed.length;
			}
			
			// Pad to 4-byte boundary
			const padding = (4 - (finalData.length % 4)) % 4;
			
			tableData.push({
				...table,
				data: finalData,
				compLength: compLength,
				outOffset: woffOffset,
				padding: padding
			});
			
			woffSize += finalData.length + padding;
			woffOffset += finalData.length + padding;
		}

		const woffBuffer = new ArrayBuffer(woffSize);
		const woffView = new DataView(woffBuffer);
		const woffBytes = new Uint8Array(woffBuffer);

		// Write Header
		woffView.setUint32(0, SIGNATURE);
		woffView.setUint32(4, FLAVOR);
		woffView.setUint32(8, woffSize);
		woffView.setUint16(12, numTables);
		woffView.setUint16(14, 0); // Reserved
		woffView.setUint32(16, ttfBuffer.byteLength); // TotalSfntSize
		woffView.setUint16(20, 1); // MajorVersion
		woffView.setUint16(22, 0); // MinorVersion
		woffView.setUint32(24, 0); // MetaOffset (none)
		woffView.setUint32(28, 0); // MetaLength
		woffView.setUint32(32, 0); // MetaOrigLength
		woffView.setUint32(36, 0); // PrivOffset (none)
		woffView.setUint32(40, 0); // PrivLength

		// Write Table Directory
		let dirOffset = HEADER_SIZE;
		for (let table of tableData) {
			writeTag(woffView, dirOffset, table.tag);
			woffView.setUint32(dirOffset + 4, table.outOffset);
			woffView.setUint32(dirOffset + 8, table.compLength);
			woffView.setUint32(dirOffset + 12, table.length);
			woffView.setUint32(dirOffset + 16, table.checkSum);
			dirOffset += 20;
		}

		// Write Data
		for (let table of tableData) {
			woffBytes.set(table.data, table.outOffset);
			// Padding is automatically 0 initialized by ArrayBuffer
		}

		return woffBuffer;
	}

	function getTag(view, offset) {
		let tag = "";
		for(let i=0; i<4; i++) {
			tag += String.fromCharCode(view.getUint8(offset+i));
		}
		return tag;
	}

	function writeTag(view, offset, tag) {
		for (let i=0; i<4; i++) {
			view.setUint8(offset+i, tag.charCodeAt(i));
		}
	}

	function updateCharDisplay() {
		if (!currentAllChars.length) return;
		
		const keptChars = keptCharsInput.value;
		const keptSet = new Set(keptChars);

		const html = currentAllChars.map(char => {
			const codePoint = char.codePointAt(0);
			const gid = Typr.U.codeToGlyph(currentOriginalFont, codePoint);
			const hex = codePoint.toString(16).toUpperCase().padStart(4, "0");
			const title = `U+${hex} (${codePoint}) - Glyph: ${gid}`;
			const className = keptSet.has(char) ? "" : "char-removed";

			return `<span class="${className}" title="${title}">${escapeHtml(char)}</span>`;
		}).join("");
		allCharsOutput.innerHTML = html;
	}

	function escapeHtml(text) {
		return text
			.replace(/&/g, "&amp;")
			.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
			.replace(/"/g, "&quot;")
			.replace(/'/g, "&#039;");
	}
</script>
</body>
</html>